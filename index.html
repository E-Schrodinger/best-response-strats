<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>State Space - Best Response Strategies</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .description {
            background-color: #f8f8f8;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #4a76a8;
        }
        .assumptions {
            font-weight: bold;
            margin-top: 10px;
        }
        .control-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        .control-group {
            flex: 1;
            min-width: 200px;
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
        }
        .slider-container {
            margin: 15px 0;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        select, button {
            padding: 8px;
            width: 100%;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        button {
            background: #4a76a8;
            color: white;
            border: none;
            padding: 12px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 10px;
        }
        button:hover {
            background: #3a5f8a;
        }
        .plot-container {
            width: 100%;
            height: 600px;
            border: 1px solid #ddd;
            margin-top: 20px;
        }
        input[type="range"] {
            width: 100%;
        }
        .value-display {
            text-align: right;
            color: #555;
        }
        .visualization-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        .visualization-toggle label {
            display: inline-flex;
            align-items: center;
            cursor: pointer;
            font-weight: normal;
        }
        .visualization-toggle input {
            margin-right: 5px;
        }
        @media (max-width: 768px) {
            .control-group {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <h1>State Space - Best Response Strategies</h1>
    
    <div class="description">
        <p>Visualization for best response strategies based on selected parameters in the prisoner's dilemma environment. Choose a state space (Win-Stay-Lose-Shift or Grim-Trigger) and visualization type. For the heatmap view, select two parameters to display on the graph along with an initial strategy and a target strategy. For the network graph view, the visualization shows how each strategy responds to the others given the fixed parameter values.</p>
        
        <div class="assumptions">
            Assumptions:
            <ul>
                <li>1 ≥ t > r > p > s ≥ 0</li>
                <li>0 < e < 1</li>
                <li>0 < d < 1</li>
            </ul>
            Any other ordering may not show accurate results.
        </div>
    </div>
    
    <div class="control-panel">
        <div class="control-group">
            <h3>State Space & Visualization</h3>
            <label for="state-space">Select State Space:</label>
            <select id="state-space">
                <option value="wsls" selected>Win-Stay-Lose-Shift (WSLS)</option>
                <option value="gt">Grim-Trigger (GT)</option>
            </select>
            
            <div class="visualization-toggle">
                <h4>Visualization Type:</h4>
                <label>
                    <input type="radio" name="visualization-type" value="heatmap" checked>
                    Parameter Heatmap
                </label>
                <label>
                    <input type="radio" name="visualization-type" value="network">
                    Network Graph
                </label>
            </div>
        </div>
        
        <div class="control-group heatmap-controls">
            <h3>Parameters to Graph (Heatmap View)</h3>
            <label for="x-axis">X-Axis Parameter:</label>
            <select id="x-axis">
                <option value="e">e - Exploration Rate</option>
                <option value="d">d - Discount Factor</option>
                <option value="t">t - Temptation Payoff (D/C)</option>
                <option value="r">r - Reward Payoff (C/C)</option>
                <option value="p">p - Punishment Payoff (D/D)</option>
                <option value="s">s - Sucker's Payoff (C/D)</option>
            </select>
            
            <label for="y-axis">Y-Axis Parameter:</label>
            <select id="y-axis">
                <option value="d">d - Discount Factor</option>
                <option value="e">e - Exploration Rate</option>
                <option value="t">t - Temptation Payoff (D/C)</option>
                <option value="r">r - Reward Payoff (C/C)</option>
                <option value="p">p - Punishment Payoff (D/D)</option>
                <option value="s">s - Sucker's Payoff (C/D)</option>
            </select>
        </div>
        
        <div class="control-group heatmap-controls">
            <h3>States (Heatmap View)</h3>
            <label for="initial-state">Initial State:</label>
            <select id="initial-state">
                <option value="0">State (0,0) - All D</option>
                <option value="1">State (0,1) - Anti-WSLS</option>
                <option value="2" selected>State (1,0) - WSLS</option>
                <option value="3">State (1,1) - All C</option>
            </select>
            
            <label for="target-state">Target State:</label>
            <select id="target-state">
                <option value="0">State (0,0) - All D</option>
                <option value="1">State (0,1) - Anti-WSLS</option>
                <option value="2" selected>State (1,0) - WSLS</option>
                <option value="3">State (1,1) - All C</option>
            </select>
        </div>
    </div>
    
    <div class="control-group">
        <h3>Parameter Controls</h3>
        <div id="sliders-container">
            <!-- Sliders will be dynamically generated here -->
        </div>
    </div>
    
    <button id="generate-btn">Generate Visualization</button>
    
    <div id="plot" class="plot-container"></div>
    
    <script>
        // Parameter ranges and default values
        const paramDefaults = {
            t: 1.0,
            r: 0.9,
            p: 0.5,
            s: 0.0,
            d: 0.5,
            e: 0.2
        };

        const paramRanges = {
            t: { min: 0.01, max: 1.0 },
            r: { min: 0.01, max: 1.0 },
            p: { min: 0.01, max: 1.0 },
            s: { min: 0.0, max: 1.0 },
            d: { min: 0.01, max: 0.99 },
            e: { min: 0.01, max: 0.99 }
        };

        const paramLabels = {
            t: "t - Temptation Payoff (D/C)",
            r: "r - Reward Payoff (C/C)",
            p: "p - Punishment Payoff (D/D)",
            s: "s - Sucker's Payoff (C/D)",
            d: "d - Discount Factor",
            e: "e - Exploration Rate"
        };

        // Define state labels for different state spaces
        const stateLabels = {
            wsls: {
                0: "(0,0) - All D",
                1: "(0,1) - Anti-WSLS",
                2: "(1,0) - WSLS",
                3: "(1,1) - All C"
            },
            gt: {
                0: "(0,0) - All D",
                1: "(0,1) - Anti-GT",
                2: "(1,0) - GT",
                3: "(1,1) - All C"
            }
        };

        // Define shorter state labels for network diagram
        const shortStateLabels = {
            wsls: {
                0: "All D",
                1: "Anti-WSLS",
                2: "WSLS",
                3: "All C"
            },
            gt: {
                0: "All D",
                1: "Anti-GT",
                2: "GT",
                3: "All C"
            }
        };

        // Convert state numbers to tuples
        function stateToTuple(state) {
            switch (parseInt(state)) {
                case 0: return [0, 0];
                case 1: return [0, 1];
                case 2: return [1, 0];
                case 3: return [1, 1];
                default: throw new Error("Invalid state");
            }
        }

        // Safe division function to handle division by zero or very small numbers
        function safeDivision(numerator, denominator) {
            try {
                if (Math.abs(denominator) < 1e-10) {
                    return numerator >= 0 ? Infinity : -Infinity;
                }
                return numerator / denominator;
            } catch {
                return Infinity;
            }
        }

        // Port of the wsls_best_response_strategy function from Python to JavaScript
        function wslsBestResponseStrategy(e, d, t, r, p, s, currentState) {
            // Convert tuple state to integer if needed
            if (Array.isArray(currentState)) {
                if (currentState[0] === 0 && currentState[1] === 0) currentState = 0;
                else if (currentState[0] === 0 && currentState[1] === 1) currentState = 1;
                else if (currentState[0] === 1 && currentState[1] === 0) currentState = 2;
                else if (currentState[0] === 1 && currentState[1] === 1) currentState = 3;
                else return null; // Invalid state
            }
            
            // State 0 {0, 0} transitions
            if (currentState === 0) {
                // 0→0
                if (p + r === s + t || e * (p + r) + 2 * s < 2 * p + e * (s + t)) {
                    return 0;
                }
                // 0→3
                else if (p + r !== s + t && 2 * p + e * (s + t) < e * (p + r) + 2 * s) {
                    return 3;
                }
                else {
                    return null;
                }
            }
            
            // State 1 {0, 1} transitions
            else if (currentState === 1) {
                try {
                    // Calculate bounds for conditions
                    const bound1Left = safeDivision(-2 * r + e * (p + r - s - t) + 2 * t, 2 * ((-1 + e) ** 2) * (p - r));
                    const bound1Right = safeDivision((-2 + e) * p + 2 * s + e * (r - s - t), 2 * ((-1 + e) ** 2) * (s - t));
                    
                    // 1→0
                    const cond10 = (bound1Left < d && d < bound1Right && 
                            ((p + r <= s + t) || (e * (p + r) + 2 * t > 2 * p + e * (s + t))));
                    
                    if (cond10) {
                        return 0;
                    }
                    
                    // 1→1
                    if (e * (p + r - s - t) + 2 * t < 2 * (d * ((-1 + e) ** 2) * (p - r) + r)) {
                        return 1;
                    }
                    
                    // 1→2
                    if (d > bound1Right) {
                        return 2;
                    }
                    
                    // 1→3
                    const bound2Left = safeDivision((-2 + e) * p + 2 * s + e * (r - s - t), 2 * ((-1 + e) ** 2) * (p - r));
                    const bound2Right = safeDivision(-2 * r + e * (p + r - s - t) + 2 * t, 2 * ((-1 + e) ** 2) * (s - t));
                    
                    const cond13 = (bound2Left < d && d < bound2Right && 
                            p + r !== s + t && 2 * r + e * (s + t) < e * (p + r) + 2 * s);
                    
                    if (cond13) {
                        return 3;
                    }
                }
                catch {
                    // If any calculation fails, continue to next check
                }
                
                return null;
            }
            
            // State 2 {1, 0} transitions
            else if (currentState === 2) {
                try {
                    // Calculate bounds for conditions
                    const bound1Left = safeDivision(-(((-2 + e) * p) - 2 * s + e * (-r + s + t)), 2 * ((-1 + e) ** 2) * (s - t));
                    const bound1Right = safeDivision(2 * (r - t) + e * (-p - r + s + t), 2 * ((-1 + e) ** 2) * (p - r));
                    
                    // 2→0
                    const cond20 = (bound1Left < d && d < bound1Right && 
                            ((p + r <= s + t) || (e * (p + r) + 2 * t > 2 * p + e * (s + t))));
                    
                    if (cond20) {
                        return 0;
                    }
                    
                    // 2→1
                    if (d < bound1Left) {
                        return 1;
                    }
                    
                    // 2→2
                    if (2 * (r - t) + e * (-p - r + s + t) > 2 * d * ((-1 + e) ** 2) * (p - r)) {
                        return 2;
                    }
                    
                    // 2→3
                    const bound2Left = safeDivision(2 * (r - t) + e * (-p - r + s + t), 2 * ((-1 + e) ** 2) * (s - t));
                    const bound2Right = safeDivision(-(((-2 + e) * p) - 2 * s + e * (-r + s + t)), 2 * ((-1 + e) ** 2) * (p - r));
                    
                    const cond23 = (bound2Left < d && d < bound2Right && 
                            p + r !== s + t && 2 * r + e * (s + t) < e * (p + r) + 2 * s);
                    
                    if (cond23) {
                        return 3;
                    }
                }
                catch {
                    // If any calculation fails, continue to next check
                }
                
                return null;
            }
            
            // State 3 {1, 1} transitions
            else if (currentState === 3) {
                // 3→0
                if (p + r === s + t || 2 * r + e * (s + t) < e * (p + r) + 2 * t) {
                    return 0;
                }
                // 3→3
                else if (p + r !== s + t && e * (p + r) + 2 * t < 2 * r + e * (s + t)) {
                    return 3;
                }
                else {
                    return null;
                }
            }
            
            else {
                return null;  // Invalid state
            }
        }
        
        // Port of the gt_best_response_strategy function from Python to JavaScript
        function gtBestResponseStrategy(e, d, t, r, p, s, currentState) {
            // Convert tuple state to integer if needed
            if (Array.isArray(currentState)) {
                if (currentState[0] === 0 && currentState[1] === 0) currentState = 0;
                else if (currentState[0] === 0 && currentState[1] === 1) currentState = 1;
                else if (currentState[0] === 1 && currentState[1] === 0) currentState = 2;
                else if (currentState[0] === 1 && currentState[1] === 1) currentState = 3;
                else return null; // Invalid state
            }
            
            // State 0 {0, 0} transitions
            if (currentState === 0) {
                // 0→0 transition
                if (p + r === s + t || e * (p + r) + 2 * s < 2 * p + e * (s + t)) {
                    return 0;
                }
                // 0→3 transition
                else if (p + r !== s + t && 2 * p + e * (s + t) < e * (p + r) + 2 * s) {
                    return 3;
                }
                else {
                    return null;
                }
            }
            
            // State 1 {0, 1} transitions
            else if (currentState === 1) {
                // 1→0 transition
                const cond_1_0_part1 = (s === 0);
                const cond_1_0_part2 = (e * (p + r) + 2 * t < 2 * p + e * (s + t) && 
                                  2 * p + e * (s + d * s + t + d * t) > 
                                  2 * s + e * (p + r + d * s) + d * (e**2) * t);
                const cond_1_0_part3 = (e * (p + r) + 2 * t >= 2 * p + e * (s + t) && 
                                  2 * (r - t) + e * (-p - r + s + t) + 
                                  d * (-1 + e) * (2 * (-1 + e) * p + 2 * t - e * (s + t)) < 0);
                
                if (cond_1_0_part1 || cond_1_0_part2 || cond_1_0_part3) {
                    return 0;
                }
                
                // 1→1 transition
                const lowerBound = safeDivision(((-2 + e) * p + 2 * s + e * (r - s - t)), 
                                        ((-1 + e) * (2 * (-1 + e) * p - (-2 + e) * s - e * t)));
                const upperBound = safeDivision((-2 * r + e * (p + r - s - t) + 2 * t), 
                                        ((-1 + e) * (2 * (-1 + e) * p + 2 * t - e * (s + t))));
                
                if (lowerBound < d && d < upperBound) {
                    return 1;
                }
                
                // 1→3 transition
                const cond_1_3_part1 = (s !== 0);
                const cond_1_3_part2 = (d < safeDivision((-2 * r + e * (p + r - s - t) + 2 * t), 
                                             ((2 - 3 * e + e**2) * (s - t))) && 
                             2 * r + e * (s + t) < e * (p + r) + 2 * s);
                const cond_1_3_part3 = (2 * (1 + d + d * e**2) * p + e * (s + 3 * d * s + t + d * t) < 
                             e * (p + 4 * d * p + r) + 2 * (1 + d) * s + d * e**2 * (s + t) &&
                             e * (p + r) + 2 * s <= 2 * r + e * (s + t));
                
                if (cond_1_3_part1 && (cond_1_3_part2 || cond_1_3_part3)) {
                    return 3;
                }
                
                return null;
            }
            
            // State 2 {1, 0} transitions
            else if (currentState === 2) {
                // 2→0 transition
                const cond_2_0_part1 = (s === 0 && 
                             e * (p + r - t) + 2 * t + 
                             d * (-1 + e) * (2 * (-1 + e) * p - (-2 + e) * t) > 2 * r);
                
                const cond_2_0_part2_subA = (e * (p + r) + 2 * t >= 2 * p + e * (s + t) || 
                                 2 * s + d * e**2 * s + e * (p + r + d * t) < 
                                 2 * p + e * (s + d * s + t + d * e * t));
                
                const cond_2_0_part2_subB = (e * (p + r) + 2 * t < 2 * p + e * (s + t) ||
                                 e * (p + r - s - t) + 2 * t + 
                                 d * (-1 + e) * (2 * (-1 + e) * p + 2 * t - e * (s + t)) > 2 * r);
                
                const cond_2_0_part2 = (s !== 0 && cond_2_0_part2_subA && cond_2_0_part2_subB);
                
                if (cond_2_0_part1 || cond_2_0_part2) {
                    return 0;
                }
                
                // 2→2 transition
                const lowerBound = safeDivision((2 * (r - t) + e * (-p - r + s + t)),
                                        ((-1 + e) * (2 * (-1 + e) * p + 2 * t - e * (s + t))));
                const upperBound = safeDivision(((-((-2 + e) * p) - 2 * s + e * (-r + s + t))), 
                                        ((-1 + e) * (2 * (-1 + e) * p - (-2 + e) * s - e * t)));
                
                if (lowerBound < d && d < upperBound) {
                    return 2;
                }
                
                // 2→3 transition
                // Part 1: 2p == s+t && s != 0 && ...
                const d_bound_2_3 = safeDivision((2 * (r - t) + e * (-p - r + s + t)), 
                                      ((2 - 3 * e + e**2) * (s - t)));
                
                const cond_2_3_part1_subA = (d > d_bound_2_3 || 2 * r + e * (s + t) > e * (p + r) + 2 * s);
                
                const cond_2_3_part1_subB = (2 * r + e * (s + t) <= e * (p + r) + 2 * s || 
                                 ((-2 + 2 * d * (-1 + e)**2 + e) * p + 
                                  e * (r + (-1 + 3 * d) * s + (-1 + d) * t) > 
                                  2 * (-1 + d) * s + d * e**2 * (s + t)));
                
                const cond_2_3_part1 = (2 * p === s + t && s !== 0 && cond_2_3_part1_subA && cond_2_3_part1_subB);
                
                // Part 2: 2p != s+t && s != 0 && ...
                const cond_2_3_part2_subA = (e * (p + r) + 2 * s >= 2 * r + e * (s + t) || 
                                 ((-2 + 2 * d * (-1 + e)**2 + e) * p + 
                                  e * (r + (-1 + 3 * d) * s + (-1 + d) * t) > 
                                  2 * (-1 + d) * s + d * e**2 * (s + t)));
                
                const cond_2_3_part2_subB = (e * (p + r) + 2 * s < 2 * r + e * (s + t) || 
                                 2 * r + 2 * d * t + d * e**2 * t + e * (s + 3 * d * s + t) > 
                                 d * e**2 * s + 2 * (d * s + t) + e * (p + r + 3 * d * t));
                
                const cond_2_3_part2 = (2 * p !== s + t && s !== 0 && cond_2_3_part2_subA && cond_2_3_part2_subB);
                
                // Part 3: s == 0 && ...
                const cond_2_3_part3 = (s === 0 && 
                             ((-2 + 2 * d * (-1 + e)**2 + e) * p + e * (r + (-1 + d - d * e) * t) > 0));
                
                if (cond_2_3_part1 || cond_2_3_part2 || cond_2_3_part3) {
                    return 3;
                }
                
                return null;
            }
            
            // State 3 {1, 1} transitions
            else if (currentState === 3) {
                // 3→0 transition
                if (p + r === s + t || 2 * r + e * (s + t) < e * (p + r) + 2 * t) {
                    return 0;
                }
                
                // 3→3 transition
                else if (p + r !== s + t && e * (p + r) + 2 * t < 2 * r + e * (s + t)) {
                    return 3;
                }
                
                return null;
            }
            
            else {
                return null;  // Invalid state
            }
        }

        // Function to update state selection dropdowns based on the selected state space
        function updateStateDropdowns() {
            const stateSpace = document.getElementById('state-space').value;
            const initialStateSelect = document.getElementById('initial-state');
            const targetStateSelect = document.getElementById('target-state');
            
            // Store current selections
            const currentInitialState = initialStateSelect.value;
            const currentTargetState = targetStateSelect.value;
            
            // Clear existing options
            initialStateSelect.innerHTML = '';
            targetStateSelect.innerHTML = '';
            
            // Add new options with the appropriate labels
            for (let i = 0; i < 4; i++) {
                const initialOption = document.createElement('option');
                initialOption.value = i;
                initialOption.textContent = stateLabels[stateSpace][i];
                initialStateSelect.appendChild(initialOption);
                
                const targetOption = document.createElement('option');
                targetOption.value = i;
                targetOption.textContent = stateLabels[stateSpace][i];
                targetStateSelect.appendChild(targetOption);
            }
            
            // Restore selections if possible
            initialStateSelect.value = currentInitialState;
            targetStateSelect.value = currentTargetState;
        }

        // Function to create parameter sliders
        function createSliders() {
            const slidersContainer = document.getElementById('sliders-container');
            const visualizationType = document.querySelector('input[name="visualization-type"]:checked').value;
            
            // Clear existing sliders
            slidersContainer.innerHTML = '';
            
            if (visualizationType === 'heatmap') {
                // For heatmap, create sliders for all parameters except x and y axes
                const xAxis = document.getElementById('x-axis').value;
                const yAxis = document.getElementById('y-axis').value;
                
                for (const param of ['t', 'r', 'p', 's', 'd', 'e']) {
                    if (param !== xAxis && param !== yAxis) {
                        createSlider(param, slidersContainer);
                    }
                }
            } else {
                // For network graph, create sliders for all parameters
                for (const param of ['t', 'r', 'p', 's', 'd', 'e']) {
                    createSlider(param, slidersContainer);
                }
            }
        }
        
        // Helper function to create a single slider
        function createSlider(param, container) {
            const sliderContainer = document.createElement('div');
            sliderContainer.className = 'slider-container';
            
            const labelContainer = document.createElement('div');
            labelContainer.style.display = 'flex';
            labelContainer.style.justifyContent = 'space-between';
            
            const label = document.createElement('label');
            label.textContent = paramLabels[param];
            label.setAttribute('for', `${param}-slider`);
            
            const valueDisplay = document.createElement('span');
            valueDisplay.id = `${param}-value`;
            valueDisplay.className = 'value-display';
            valueDisplay.textContent = paramDefaults[param].toFixed(2);
            
            labelContainer.appendChild(label);
            labelContainer.appendChild(valueDisplay);
            
            const slider = document.createElement('input');
            slider.type = 'range';
            slider.id = `${param}-slider`;
            slider.min = paramRanges[param].min;
            slider.max = paramRanges[param].max;
            slider.step = 0.01;
            slider.value = paramDefaults[param];
            
            slider.addEventListener('input', function() {
                valueDisplay.textContent = Number(this.value).toFixed(2);
            });
            
            sliderContainer.appendChild(labelContainer);
            sliderContainer.appendChild(slider);
            container.appendChild(sliderContainer);
        }

        // Function to get current parameter values
        function getParameterValues() {
            const visualizationType = document.querySelector('input[name="visualization-type"]:checked').value;
            
            const params = {
                t: paramDefaults.t,
                r: paramDefaults.r,
                p: paramDefaults.p,
                s: paramDefaults.s,
                d: paramDefaults.d,
                e: paramDefaults.e
            };
            
            // For heatmap, exclude x and y axis parameters
            if (visualizationType === 'heatmap') {
                const xAxis = document.getElementById('x-axis').value;
                const yAxis = document.getElementById('y-axis').value;
                
                // Update from sliders
                for (const param of ['t', 'r', 'p', 's', 'd', 'e']) {
                    if (param !== xAxis && param !== yAxis) {
                        const slider = document.getElementById(`${param}-slider`);
                        if (slider) {
                            params[param] = parseFloat(slider.value);
                        }
                    }
                }
                
                return {
                    params,
                    xAxis,
                    yAxis
                };
            } else {
                // For network graph, get all parameters
                for (const param of ['t', 'r', 'p', 's', 'd', 'e']) {
                    const slider = document.getElementById(`${param}-slider`);
                    if (slider) {
                        params[param] = parseFloat(slider.value);
                    }
                }
                
                return {
                    params
                };
            }
        }

        // Function to generate best response data for heatmap
        function generateBestResponseData(resolution = 100) {
            const { params, xAxis, yAxis } = getParameterValues();
            const initialState = parseInt(document.getElementById('initial-state').value);
            const targetState = parseInt(document.getElementById('target-state').value);
            const stateSpace = document.getElementById('state-space').value;
            
            // Create arrays for x and y values
            const xValues = Array.from({ length: resolution }, (_, i) => 
                paramRanges[xAxis].min + (paramRanges[xAxis].max - paramRanges[xAxis].min) * i / (resolution - 1));
            
            const yValues = Array.from({ length: resolution }, (_, i) => 
                paramRanges[yAxis].min + (paramRanges[yAxis].max - paramRanges[yAxis].min) * i / (resolution - 1));
            
            // Initialize result matrix (all zeros)
            const result = Array(resolution).fill().map(() => Array(resolution).fill(0));
            
            // Choose the appropriate strategy function
            const strategyFunction = stateSpace === 'wsls' ? wslsBestResponseStrategy : gtBestResponseStrategy;
            
            // Evaluate each point
            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const xVal = xValues[i];
                    const yVal = yValues[j];
                    
                    // Create a copy of params and update with current x and y values
                    const currentParams = { ...params };
                    currentParams[xAxis] = xVal;
                    currentParams[yAxis] = yVal;
                    
                    // Get the best action for this state and parameters
                    const bestAction = strategyFunction(
                        currentParams.e, currentParams.d, currentParams.t, 
                        currentParams.r, currentParams.p, currentParams.s, 
                        initialState
                    );
                    
                    // Check if the best action is the target
                    if (bestAction === targetState) {
                        result[j][i] = 1;  // Transpose to match x/y axes
                    }
                }
            }
            
            return { xValues, yValues, result };
        }

        // Function to compute all best responses for network graph
        function computeAllBestResponses() {
            const { params } = getParameterValues();
            const stateSpace = document.getElementById('state-space').value;
            
            // Choose the appropriate strategy function
            const strategyFunction = stateSpace === 'wsls' ? wslsBestResponseStrategy : gtBestResponseStrategy;
            
            // Compute best responses for all states
            const bestResponses = [];
            
            for (let state = 0; state < 4; state++) {
                const response = strategyFunction(
                    params.e, params.d, params.t, params.r, params.p, params.s, state
                );
                
                if (response !== null) {
                    bestResponses.push({
                        from: state,
                        to: response
                    });
                }
            }
            
            return bestResponses;
        }

        // Function to plot the best response heatmap
        function plotBestResponseHeatmap() {
            const { params, xAxis, yAxis } = getParameterValues();
            const initialState = document.getElementById('initial-state').value;
            const targetState = document.getElementById('target-state').value;
            const stateSpace = document.getElementById('state-space').value;
            
            // Get the state labels for the current state space
            const initialStateLabel = stateLabels[stateSpace][initialState];
            const targetStateLabel = stateLabels[stateSpace][targetState]; 
            
            // Get the state space label
            const stateSpaceLabel = stateSpace === 'wsls' ? 'Win-Stay-Lose-Shift' : 'Grim-Trigger';
            
            // Generate data
            const { xValues, yValues, result } = generateBestResponseData();
            
            // Create a heatmap trace with binary colorscale
            const trace = {
                z: result,
                x: xValues,
                y: yValues,
                type: 'heatmap',
                colorscale: [
                    [0, 'white'],
                    [0.5, 'white'],
                    [0.5, 'blue'],
                    [1, 'blue']
                ],
                zmin: 0,
                zmax: 1,
                showscale: true,
                colorbar: {
                    title: `Is ${targetStateLabel} a best response to ${initialStateLabel}?`,
                    tickvals: [0, 1],
                    ticktext: ['No', 'Yes']
                }
            };
            
            // Format other parameters for the title
            const otherParams = Object.entries(params)
                .filter(([key, _]) => key !== xAxis && key !== yAxis)
                .map(([key, value]) => `${key}=${value.toFixed(2)}`)
                .join(', ');
            
            // Create the layout
            const layout = {
                title: `Regions where ${targetStateLabel} is a best response to ${initialStateLabel} in ${stateSpaceLabel} State Space<br>(${otherParams})`,
                xaxis: {
                    title: paramLabels[xAxis],
                    range: [paramRanges[xAxis].min, paramRanges[xAxis].max]
                },
                yaxis: {
                    title: paramLabels[yAxis],
                    range: [paramRanges[yAxis].min, paramRanges[yAxis].max]
                },
                width: document.getElementById('plot').offsetWidth,
                height: document.getElementById('plot').offsetHeight
            };
            
            // Create the plot
            Plotly.newPlot('plot', [trace], layout);
        }

        // Function to plot the best response network graph
        function plotBestResponseNetwork() {
            const { params } = getParameterValues();
            const stateSpace = document.getElementById('state-space').value;
            
            // Get the state space label
            const stateSpaceLabel = stateSpace === 'wsls' ? 'Win-Stay-Lose-Shift' : 'Grim-Trigger';
            
            // Compute best responses
            const bestResponses = computeAllBestResponses();
            
            // Define node positions (square layout)
            const nodePositions = [
                {x: 0, y: 0},   // (0,0) - All D
                {x: 1, y: 0},   // (0,1) - Anti-WSLS/GT
                {x: 0, y: 1},   // (1,0) - WSLS/GT
                {x: 1, y: 1}    // (1,1) - All C
            ];
            
            // Create nodes
            const nodes = {
                x: nodePositions.map(p => p.x),
                y: nodePositions.map(p => p.y),
                mode: 'markers+text',
                marker: {
                    size: 30,
                    color: ['red', 'orange', 'green', 'blue']
                },
                text: Array.from({length: 4}, (_, i) => shortStateLabels[stateSpace][i]),
                textposition: 'bottom center',
                hoverinfo: 'text',
                hovertext: Array.from({length: 4}, (_, i) => stateLabels[stateSpace][i]),
                type: 'scatter'
            };
            
            // Create edges
            const edges = [];
            
            for (const response of bestResponses) {
                const fromPos = nodePositions[response.from];
                const toPos = nodePositions[response.to];
                
                // Don't draw self-loops as arrows (handled separately)
                if (response.from !== response.to) {
                    // Calculate arrow positions with slight curve for aesthetics
                    const midX = (fromPos.x + toPos.x) / 2;
                    const midY = (fromPos.y + toPos.y) / 2;
                    
                    // Adjust for potential bidirectional edges
                    const hasBidirectional = bestResponses.some(r => 
                        r.from === response.to && r.to === response.from
                    );
                    
                    // If bidirectional, curve the edges
                    const curveFactor = hasBidirectional ? 0.2 : 0;
                    
                    // Perpendicular vector to create curve
                    const dx = toPos.x - fromPos.x;
                    const dy = toPos.y - fromPos.y;
                    const perpX = -dy;
                    const perpY = dx;
                    
                    const controlX = midX + perpX * curveFactor;
                    const controlY = midY + perpY * curveFactor;
                    
                    // Create annotation for the arrow
                    edges.push({
                        x: [fromPos.x, controlX, toPos.x],
                        y: [fromPos.y, controlY, toPos.y],
                        mode: 'lines',
                        line: {
                            width: 2,
                            color: 'black',
                            shape: hasBidirectional ? 'spline' : 'linear'
                        },
                        hoverinfo: 'none',
                        type: 'scatter'
                    });
                    
                    // Add arrowhead annotation
                    // We'll handle this in the layout
                }
            }
            
            // Add self-loops as separate traces
            for (const response of bestResponses) {
                if (response.from === response.to) {
                    const pos = nodePositions[response.from];
                    
                    // Create a loop above the node
                    const loopSize = 0.15;
                    const loopX = [
                        pos.x, 
                        pos.x + loopSize, 
                        pos.x, 
                        pos.x - loopSize, 
                        pos.x
                    ];
                    const loopY = [
                        pos.y, 
                        pos.y + loopSize, 
                        pos.y + loopSize * 2, 
                        pos.y + loopSize, 
                        pos.y
                    ];
                    
                    edges.push({
                        x: loopX,
                        y: loopY,
                        mode: 'lines',
                        line: {
                            width: 2,
                            color: 'black',
                            shape: 'spline'
                        },
                        hoverinfo: 'none',
                        type: 'scatter'
                    });
                }
            }
            
            // Create arrowhead annotations
            const annotations = [];
            
            for (const response of bestResponses) {
                // Skip self-loops for annotations, handled separately
                if (response.from !== response.to) {
                    const fromPos = nodePositions[response.from];
                    const toPos = nodePositions[response.to];
                    
                    // Check if bidirectional
                    const hasBidirectional = bestResponses.some(r => 
                        r.from === response.to && r.to === response.from
                    );
                    
                    // Calculate vector from -> to
                    const dx = toPos.x - fromPos.x;
                    const dy = toPos.y - fromPos.y;
                    
                    // Normalize and scale to avoid overlapping with nodes
                    const length = Math.sqrt(dx*dx + dy*dy);
                    const scale = 0.8; // Reduce length to avoid overlapping
                    const normalizedDx = dx / length * scale;
                    const normalizedDy = dy / length * scale;
                    
                    // Adjust for potential bidirectional edges
                    const curveFactor = hasBidirectional ? 0.2 : 0;
                    
                    // Perpendicular vector to create curve
                    const perpX = -dy;
                    const perpY = dx;
                    
                    // Calculate arrow endpoint with curve adjustment
                    const endX = fromPos.x + normalizedDx + perpX * curveFactor;
                    const endY = fromPos.y + normalizedDy + perpY * curveFactor;
                    
                    annotations.push({
                        x: toPos.x,
                        y: toPos.y,
                        xref: 'x',
                        yref: 'y',
                        axref: 'x',
                        ayref: 'y',
                        ax: endX,
                        ay: endY,
                        showarrow: true,
                        arrowhead: 3,
                        arrowsize: 1.5,
                        arrowwidth: 2,
                        standoff: 15  // Distance from the end of the arrow to the point
                    });
                }
            }
            
            // Format parameter values for the title
            const paramsString = Object.entries(params)
                .map(([key, value]) => `${key}=${value.toFixed(2)}`)
                .join(', ');
            
            // Create the layout
            const layout = {
                title: `Best Response Network for ${stateSpaceLabel} State Space<br>(${paramsString})`,
                showlegend: false,
                xaxis: {
                    range: [-0.2, 1.2],
                    zeroline: false,
                    showgrid: false,
                    showticklabels: false,
                    fixedrange: true
                },
                yaxis: {
                    range: [-0.2, 1.2],
                    zeroline: false,
                    showgrid: false,
                    showticklabels: false,
                    fixedrange: true,
                    scaleanchor: 'x',
                    scaleratio: 1
                },
                annotations: annotations,
                hovermode: 'closest',
                width: document.getElementById('plot').offsetWidth,
                height: document.getElementById('plot').offsetHeight
            };
            
            // Combine all traces
            const allTraces = [nodes, ...edges];
            
            // Create the plot
            Plotly.newPlot('plot', allTraces, layout);
        }

        // Function to update the UI based on the selected visualization type
        function updateUI() {
            const visualizationType = document.querySelector('input[name="visualization-type"]:checked').value;
            const heatmapControls = document.querySelectorAll('.heatmap-controls');
            
            // Show/hide heatmap controls
            heatmapControls.forEach(control => {
                control.style.display = visualizationType === 'heatmap' ? 'block' : 'none';
            });
            
            // Update sliders
            createSliders();
        }

        // Function to generate visualization based on current settings
        function generateVisualization() {
            const visualizationType = document.querySelector('input[name="visualization-type"]:checked').value;
            
            if (visualizationType === 'heatmap') {
                plotBestResponseHeatmap();
            } else {
                plotBestResponseNetwork();
            }
        }

        // Initialize the page
        function initialize() {
            // Set up event listeners
            document.getElementById('x-axis').addEventListener('change', createSliders);
            document.getElementById('y-axis').addEventListener('change', createSliders);
            document.getElementById('state-space').addEventListener('change', function() {
                // Update state dropdowns and re-generate visualization when state space changes
                updateStateDropdowns();
                generateVisualization();
            });
            
            // Add event listeners for visualization type toggle
            document.querySelectorAll('input[name="visualization-type"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    updateUI();
                    // Don't auto-generate to avoid performance issues - let user click the button
                });
            });
            
            document.getElementById('generate-btn').addEventListener('click', generateVisualization);
            
            // Initialize state dropdowns
            updateStateDropdowns();
            
            // Initialize UI based on default visualization type
            updateUI();
            
            // Generate an initial visualization
            generateVisualization();
        }

        // Start the app when the page loads
        window.addEventListener('load', initialize);
    </script>
</body>
</html>